#include "token.h"
#include "com_assert.h"
#include "com_str.h"

com_str tk_strKind(tk_Kind val) {
  switch (val) {
  case tk_Eof:
    return com_str_lit_m("tk_Eof");
  case tk_None:
    return com_str_lit_m("tk_None");
  case tk_Identifier:
    return com_str_lit_m("tk_Identifier");
  case tk_Loop:
    return com_str_lit_m("tk_Loop");
  case tk_Self:
    return com_str_lit_m("tk_Self");
  case tk_Append:
    return com_str_lit_m("tk_Append");
  case tk_Of:
    return com_str_lit_m("tk_Of");
  case tk_Pat:
    return com_str_lit_m("tk_Pat");
  case tk_Void:
    return com_str_lit_m("tk_Void");
  case tk_VoidType:
    return com_str_lit_m("tk_VoidType");
  case tk_NeverType:
    return com_str_lit_m("tk_NeverType");
  case tk_Case:
    return com_str_lit_m("tk_Case");
  case tk_CaseOption:
    return com_str_lit_m("tk_CaseOption");
  case tk_Ret:
    return com_str_lit_m("tk_Ret");
  case tk_Defer:
    return com_str_lit_m("tk_Defer");
  case tk_Where:
    return com_str_lit_m("tk_Where");
  case tk_At:
    return com_str_lit_m("tk_At");
  case tk_Dyn:
    return com_str_lit_m("tk_Dyn");
  case tk_Impl:
    return com_str_lit_m("tk_Impl");
  case tk_In:
    return com_str_lit_m("tk_In");
  case tk_String:
    return com_str_lit_m("tk_String");
  case tk_Nan:
    return com_str_lit_m("tk_Nan");
  case tk_Label:
    return com_str_lit_m("tk_Label");
  case tk_Inf:
    return com_str_lit_m("tk_Inf");
  case tk_Real:
    return com_str_lit_m("tk_Real");
  case tk_Int:
    return com_str_lit_m("tk_Int");
  case tk_Add:
    return com_str_lit_m("tk_Add");
  case tk_Sub:
    return com_str_lit_m("tk_Sub");
  case tk_Mul:
    return com_str_lit_m("tk_Mul");
  case tk_Div:
    return com_str_lit_m("tk_Div");
  case tk_Rem:
    return com_str_lit_m("tk_Rem");
  case tk_Pow:
    return com_str_lit_m("tk_Pow");
  case tk_Difference:
    return com_str_lit_m("tk_Difference");
  case tk_Sequence:
    return com_str_lit_m("tk_Sequence");
  case tk_Compose:
    return com_str_lit_m("tk_Compose");
  case tk_Union:
    return com_str_lit_m("tk_Union");
  case tk_Intersection:
    return com_str_lit_m("tk_Intersection");
  case tk_Cons:
    return com_str_lit_m("tk_Cons");
  case tk_Sum:
    return com_str_lit_m("tk_Sum");
  case tk_Range:
    return com_str_lit_m("tk_Range");
  case tk_RangeInclusive:
    return com_str_lit_m("tk_RangeInclusive");
  case tk_CompEqual:
    return com_str_lit_m("tk_CompEqual");
  case tk_CompNotEqual:
    return com_str_lit_m("tk_CompNotEqual");
  case tk_CompLess:
    return com_str_lit_m("tk_CompLess");
  case tk_CompLessEqual:
    return com_str_lit_m("tk_CompLessEqual");
  case tk_CompGreater:
    return com_str_lit_m("tk_CompGreater");
  case tk_CompGreaterEqual:
    return com_str_lit_m("tk_CompGreaterEqual");
  case tk_Assign:
    return com_str_lit_m("tk_Assign");
  case tk_RevApply:
    return com_str_lit_m("tk_RevApply");
  case tk_Arrow:
    return com_str_lit_m("tk_Arrow");
  case tk_Ignore:
    return com_str_lit_m("tk_BindIgnore");
  case tk_ParenLeft:
    return com_str_lit_m("tk_ParenLeft");
  case tk_ParenRight:
    return com_str_lit_m("tk_ParenRight");
  case tk_BracketLeft:
    return com_str_lit_m("tk_BracketLeft");
  case tk_BracketRight:
    return com_str_lit_m("tk_BracketRight");
  case tk_BraceLeft:
    return com_str_lit_m("tk_BraceLeft");
  case tk_BraceRight:
    return com_str_lit_m("tk_BraceRight");
  case tk_ModuleAccess:
    return com_str_lit_m("tk_ModuleAccess");
  case tk_Constrain:
    return com_str_lit_m("tk_Constrain");
  case tk_Metadata:
    return com_str_lit_m("tk_Metadata");
  case tk_Bind:
    return com_str_lit_m("tk_Bind");
  case tk_Splat:
    return com_str_lit_m("tk_Splat");
  case tk_PipeForward:
    return com_str_lit_m("tk_PipeForward");
  case tk_PipeBackward:
    return com_str_lit_m("tk_PipeBackward");
  case tk_And:
    return com_str_lit_m("tk_And");
  case tk_Or:
    return com_str_lit_m("tk_Or");
  case tk_If:
    return com_str_lit_m("tk_If");
  case tk_Then:
    return com_str_lit_m("tk_Then");
  case tk_Else:
    return com_str_lit_m("tk_Else");
  }

  com_assert_unreachable_m("control flow reaches end of token");
}
