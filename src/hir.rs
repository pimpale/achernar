use super::ast;
use num_bigint::{BigInt, BigUint};
use num_rational::BigRational;
use std::alloc::Allocator;

#[derive(Debug)]
pub enum CaseSource {
  Case,
  IfElse,
  And,
  Or,
}

#[derive(Debug)]
pub enum UseKind {
  Take,
  UniqBorrow,
  Borrow,
}

// HA -> HirAllocator

#[derive(Debug)]
pub enum ValExprKind<'hir, 'ast, HA: Allocator + Clone> {
  // Error in parsing
  Error,
  // Loops until a scope is returned
  Loop(&'hir ValExpr<'hir, 'ast, HA>),
  // applies a function
  App {
    fun: &'hir ValExpr<'hir, 'ast, HA>,
    arg: &'hir ValExpr<'hir, 'ast, HA>,
  },
  // constructs a new compound ty
  Struct(Vec<(&'ast Vec<u8>, (&'ast ast::Expr, ValExpr<'hir, 'ast, HA>)), HA>),

  // use place
  Use(&'hir PlaceExpr<'hir, 'ast, HA>, UseKind),

  // Annotate the value with the type
  Annotate {
    val_expr: &'hir ValExpr<'hir, 'ast, HA>,
    ty_expr: &'hir ValExpr<'hir, 'ast, HA>,
  },
  // Switches on a pattern
  CaseOf {
    expr: &'hir PlaceExpr<'hir, 'ast, HA>,
    case_options: Vec<(RefutablePatExpr<'hir, 'ast, HA>, ValExpr<'hir, 'ast, HA>), HA>,
    source: CaseSource,
  },

  // Literals
  Universe(BigUint), // type of a type is Universe(0)
  Nil,
  Bool(bool),
  Char(u32),
  Int(&'ast BigInt),
  Float(&'ast BigRational),

  // Type stuff
  // creates a pub struct from an ad hoc compound object
  StructTy(Vec<(&'ast Vec<u8>, (&'ast ast::Expr, ValExpr<'hir, 'ast, HA>)), HA>),
  // creates a disjoint union from an ad hoc compound object
  EnumTy(Vec<(&'ast Vec<u8>, (&'ast ast::Expr, ValExpr<'hir, 'ast, HA>)), HA>),
  // creates a tuple
  Pair {
    fst: &'hir ValExpr<'hir, 'ast, HA>,
    snd: &'hir ValExpr<'hir, 'ast, HA>,
  },
  // Create Function
  Lam {
    // a function body cannot directly access an external variable
    // everything must come from the captured_vars struct,
    // a struct that is generated by inspecting the body
    // 1. A take in the body means we take in the captured_vars struct, and replace with take from captured_vars
    // 2. A borrow in the body means that we borrow in the captured_vars struct, and replace with take from captured_vars
    // 3. A uniqborrow in the body means that we borrow in the captured_vars struct, and replace with take from captured_vars

    // the captured vars vec is created when a lambda is defined
    captured_vars: Vec<(&'ast [u8], (&'ast ast::Expr, ValExpr<'hir, 'ast, HA>)), HA>,
    // when a lambda is applied,
    // the use_kind determines whether running the lambda will borrow, uniqborrow, or take it
    use_kind: UseKind,
    // The args are evaluated with access to the captured vars
    arg: &'hir IrrefutablePatExpr<'hir, 'ast, HA>,
    // the code body is evaluated once the args and the captured vars both exist
    body: &'hir ValExpr<'hir, 'ast, HA>,
  },
  LamTy {
    // the type of the body
    arg_ty: &'hir ValExpr<'hir, 'ast, HA>,
    // a function from arg_ty -> Type yielding the output type
    body_dep_ty: &'hir ValExpr<'hir, 'ast, HA>,
    // how many times it may be evaluated
    use_kind: UseKind,
  },
  // Sequence
  Sequence {
    fst: &'hir ValExpr<'hir, 'ast, HA>,
    snd: &'hir ValExpr<'hir, 'ast, HA>,
  },
  // Assign value to place
  LetIn {
    pat: &'hir IrrefutablePatExpr<'hir, 'ast, HA>,
    val: &'hir ValExpr<'hir, 'ast, HA>,
    body: &'hir ValExpr<'hir, 'ast, HA>,
  },
}

#[derive(Debug)]
pub struct ValExpr<'hir, 'ast, HA: Allocator + Clone> {
  pub source: &'ast ast::Expr,
  pub kind: ValExprKind<'hir, 'ast, HA>,
  pub id: Option<u64>,
}

#[derive(Debug)]
pub enum PlaceExprKind<'hir, 'ast, HA: Allocator + Clone> {
  Error,
  // creates
  StructField {
    root: &'hir PlaceExpr<'hir, 'ast, HA>,
    field_source: &'ast ast::Expr,
    field: &'ast Vec<u8>,
  },
  // dereferncing a pointer gives a place
  Deref(&'hir ValExpr<'hir, 'ast, HA>),
  // A reference to a previously defined variable
  // debruijin index
  Var(usize),
  // A reference to the captured enviroment struct
  CapturedVar(usize),
  Builtin(Builtin),
}

#[derive(Debug)]
pub struct PlaceExpr<'hir, 'ast, HA: Allocator + Clone> {
  pub source: &'ast ast::Expr,
  pub kind: PlaceExprKind<'hir, 'ast, HA>,
}

// A pattern that may not be rejected, and can bind variables
#[derive(Debug)]
pub enum IrrefutablePatExprKind<'hir, 'ast, HA: Allocator + Clone> {
  // An error when parsing
  Error,
  // Always matches with Nil, but doesn't bind anything
  Nil,
  // Irrefutably matches a single element to new variable
  BindVariable,
  // destructure a tuple
  Pair {
    fst: &'hir IrrefutablePatExpr<'hir, 'ast, HA>,
    snd: &'hir IrrefutablePatExpr<'hir, 'ast, HA>,
  },
  // Selects a function and calls it with the scrutinee.
  // The result is then refutably matched with the argument provided
  // Also can be used to drop values during matching
  // Example: Array($a, $b, $c) = someFunc();
  // Example: _ () = someFunc();
  ActivePattern {
    fun: &'hir ValExpr<'hir, 'ast, HA>,
    arg: &'hir IrrefutablePatExpr<'hir, 'ast, HA>,
  },
  // Depub structures a field of a pub struct object
  Struct(
    Vec<
      (
        &'ast Vec<u8>,
        (&'ast ast::Expr, IrrefutablePatExpr<'hir, 'ast, HA>),
      ),
      HA,
    >,
  ),
}

#[derive(Debug)]
pub struct IrrefutablePatExpr<'hir, 'ast, HA: Allocator + Clone> {
  pub source: &'ast ast::Expr,
  pub kind: IrrefutablePatExprKind<'hir, 'ast, HA>,
  pub id: Option<u64>,
}

// A pattern that may reject, and can bind variables
#[derive(Debug)]
pub enum RefutablePatExprKind<'hir, 'ast, HA: Allocator + Clone> {
  // An error when parsing
  Error,
  // Irrefutably match this expr
  IrrefutablePat(&'hir IrrefutablePatExpr<'hir, 'ast, HA>),
  // Match against a value or fail
  ValPat(&'hir ValPatExpr<'hir, 'ast, HA>),
  // destructure a tuple
  Pair {
    fst: &'hir RefutablePatExpr<'hir, 'ast, HA>,
    snd: &'hir RefutablePatExpr<'hir, 'ast, HA>,
  },
  // Selects a function and calls it with the scrutinee.
  // The result is then refutably matched with the argument provided
  // Also can be used to drop values during matching
  // Example: Array($a, $b, $c) = someFunc();
  // Example: _ () = someFunc();
  ActivePattern {
    fun: &'hir ValExpr<'hir, 'ast, HA>,
    arg: &'hir IrrefutablePatExpr<'hir, 'ast, HA>,
  },
  // Depub structures a field of a pub struct object
  Struct(
    Vec<
      (
        &'ast Vec<u8>,
        (&'ast ast::Expr, RefutablePatExpr<'hir, 'ast, HA>),
      ),
      HA,
    >,
  ),
  // Evaluates the second pattern iff the first pattern matches, matches if both are true
  // none of these may bind any variables
  And {
    fst: &'hir RefutablePatExpr<'hir, 'ast, HA>,
    snd: &'hir RefutablePatExpr<'hir, 'ast, HA>,
  },
}

#[derive(Debug)]
pub struct RefutablePatExpr<'hir, 'ast, HA: Allocator + Clone> {
  pub source: &'ast ast::Expr,
  pub kind: RefutablePatExprKind<'hir, 'ast, HA>,
  pub id: Option<u64>,
}

// a pattern that can reject, and can't bind any variables
#[derive(Debug)]
pub enum ValPatExprKind<'hir, 'ast, HA: Allocator + Clone> {
  // An error when parsing
  Error,
  // Irrefutably discards a variable
  Ignore,
  // match with a variety of types
  Range {
    inclusive: bool,
    fst: &'hir ValExpr<'hir, 'ast, HA>,
    snd: &'hir ValExpr<'hir, 'ast, HA>,
  },
  // Selects a function and calls it with the scrutinee.
  // The result is then refutably matched with the argument provided
  // Also can be used to drop values during matching
  // Example: Array($a, $b, $c) = someFunc();
  // Example: _ () = someFunc();
  ActivePattern {
    fun: &'hir ValExpr<'hir, 'ast, HA>,
    arg: &'hir ValPatExpr<'hir, 'ast, HA>,
  },
  // Destructures a field of a struct object
  Struct(Vec<(&'ast Vec<u8>, (&'ast ast::Expr, ValPatExpr<'hir, 'ast, HA>)), HA>),
  // destructure a tuple
  Pair {
    fst: &'hir ValPatExpr<'hir, 'ast, HA>,
    snd: &'hir ValPatExpr<'hir, 'ast, HA>,
  },
  // Evaluates the second pattern iff the first pattern matches, matches if both are true
  // none of these may bind any variables
  And {
    fst: &'hir ValPatExpr<'hir, 'ast, HA>,
    snd: &'hir ValPatExpr<'hir, 'ast, HA>,
  },
  // Evaluates the second pattern iff the first pattern doesn't match, matches if at least one is true
  // none of these may bind any variables
  Or {
    fst: &'hir ValPatExpr<'hir, 'ast, HA>,
    snd: &'hir ValPatExpr<'hir, 'ast, HA>,
  },
  // Refutable pattern of a value
  // TODO: this is not really correct, we want to have a pattern for int, bool, string, and tuple only
  // everything else has to be done via transformer functions
  Value(&'hir ValExpr<'hir, 'ast, HA>),
}

#[derive(Debug)]
pub struct ValPatExpr<'hir, 'ast, HA: Allocator + Clone> {
  pub source: &'ast ast::Expr,
  pub kind: ValPatExprKind<'hir, 'ast, HA>,
  pub id: Option<u64>,
}

#[derive(Debug)]
pub enum IntOp {
  Add,         // u -> u -> u
  AddOverflow, // u -> u -> (u, u)
  Sub,         // u -> u -> u
  SubOverflow, // u -> u -> (u, u)
  Mul,         // u -> u -> u
  MulOverflow, // u -> u -> (u, u)
  Div,         // u -> u -> u
  Rem,         // u -> u -> u
  DivRem,      // u -> u -> (u, u)
  ShlL,        // u -> u -> u
  ShrL,        // u -> u -> u
  ShrA,        // u -> u -> u
  Rol,         // u -> u -> u
  Ror,         // u -> u -> u
  And,         // u -> u -> u
  Or,          // u -> u -> u
  Xor,         // u -> u -> u
  Inv,         // u -> u
  Neg,         // u -> u
}

#[derive(Debug)]
pub enum FloatOp {
  Add,    // f -> f -> f
  Sub,    // f -> f -> f
  Mul,    // f -> f -> f
  Div,    // f -> f -> f
  Rem,    // f -> f -> f
  DivRem, // f -> f -> (f, f)
  Neg,    // f -> f
}

#[derive(Debug)]
pub enum RoundingMode {
  RNE, // round to nearest even
  RTZ, // round to zero
  RDN, // round down
  RUP, // round up
}

#[derive(Debug)]
pub struct IntTy {
  signed: bool,
  size: u8,
}

#[derive(Debug)]
pub struct FloatTy {
  size: u8,
}

#[derive(Debug)]
pub enum Builtin {
  NilTy,
  NeverTy,
  BoolTy,
  // Math with bools
  BoolNot,
  // Ints
  IntTy(IntTy),
  // Floats
  FloatTy(FloatTy),
  // Math with ints
  IntOp { ty: IntTy, op: IntOp },
  // Math with floats
  FloatOp { ty: FloatTy, op: FloatOp },
  // Convert one kind of type to another
  ConvIntIntOp { src: IntTy, dest: IntTy },
  ConvIntFloatOp { src: IntTy, dest: FloatTy },
  ConvFloatIntOp { src: FloatTy, dest: IntTy },
  ConvFloatFloatOp { src: FloatTy, dest: FloatTy },
  // Handle Memory addresses
  Ref,
  Deref,
  // Forget memory
  Forget,
}
