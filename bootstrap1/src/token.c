#include "token.h"
#include "com_str.h"
#include "com_assert.h"

com_str tk_strKind(tk_Kind val) {
  switch (val) {
  case tk_Eof:
    return com_str_lit_m("tk_Eof");
  case tk_None:
    return com_str_lit_m("tk_None");
  case tk_Identifier:
    return com_str_lit_m("tk_Identifier");
  case tk_Loop:
    return com_str_lit_m("tk_Loop");
  case tk_Match:
    return com_str_lit_m("tk_Match");
  case tk_Ret:
    return com_str_lit_m("tk_Ret");
  case tk_Defer:
    return com_str_lit_m("tk_Defer");
  case tk_Where:
    return com_str_lit_m("tk_Where");
  case tk_Mut:
    return com_str_lit_m("tk_Mut");
  case tk_At:
    return com_str_lit_m("tk_At");
  case tk_Dyn:
    return com_str_lit_m("tk_Dyn");
  case tk_Impl:
    return com_str_lit_m("tk_Impl");
  case tk_Has:
    return com_str_lit_m("tk_Has");
  case tk_String:
    return com_str_lit_m("tk_String");
  case tk_Nan:
    return com_str_lit_m("tk_Nan");
  case tk_Inf:
    return com_str_lit_m("tk_Inf");
  case tk_Real:
    return com_str_lit_m("tk_Real");
  case tk_Int:
    return com_str_lit_m("tk_Int");
  case tk_Pos:
    return com_str_lit_m("tk_Pos");
  case tk_Neg:
    return com_str_lit_m("tk_Neg");
  case tk_Add:
    return com_str_lit_m("tk_Add");
  case tk_Sub:
    return com_str_lit_m("tk_Sub");
  case tk_Mul:
    return com_str_lit_m("tk_Mul");
  case tk_Div:
    return com_str_lit_m("tk_Div");
  case tk_Rem:
    return com_str_lit_m("tk_Rem");
  case tk_Union:
    return com_str_lit_m("tk_Union");
  case tk_Difference:
    return com_str_lit_m("tk_Difference");
  case tk_Intersection:
    return com_str_lit_m("tk_Intersection");
  case tk_SymDifference:
    return com_str_lit_m("tk_SymDifference");
  case tk_Product:
    return com_str_lit_m("tk_Product");
  case tk_Sum:
    return com_str_lit_m("tk_Sum");
  case tk_Ref:
    return com_str_lit_m("tk_Ref");
  case tk_Deref:
    return com_str_lit_m("tk_Deref");
  case tk_And:
    return com_str_lit_m("tk_And");
  case tk_Or:
    return com_str_lit_m("tk_Or");
  case tk_Not:
    return com_str_lit_m("tk_Not");
  case tk_Xor:
    return com_str_lit_m("tk_Xor");
  case tk_Range:
    return com_str_lit_m("tk_Range");
  case tk_RangeInclusive:
    return com_str_lit_m("tk_RangeInclusive");
  case tk_CompEqual:
    return com_str_lit_m("tk_CompEqual");
  case tk_CompNotEqual:
    return com_str_lit_m("tk_CompNotEqual");
  case tk_CompLess:
    return com_str_lit_m("tk_CompLess");
  case tk_CompLessEqual:
    return com_str_lit_m("tk_CompLessEqual");
  case tk_CompGreater:
    return com_str_lit_m("tk_CompGreater");
  case tk_CompGreaterEqual:
    return com_str_lit_m("tk_CompGreaterEqual");
  case tk_Assign:
    return com_str_lit_m("tk_Assign");
  case tk_Pipe:
    return com_str_lit_m("tk_Pipe");
  case tk_Arrow:
    return com_str_lit_m("tk_Arrow");
  case tk_Ignore:
    return com_str_lit_m("tk_BindIgnore");
  case tk_ParenLeft:
    return com_str_lit_m("tk_ParenLeft");
  case tk_ParenRight:
    return com_str_lit_m("tk_ParenRight");
  case tk_BracketLeft:
    return com_str_lit_m("tk_BracketLeft");
  case tk_BracketRight:
    return com_str_lit_m("tk_BracketRight");
  case tk_BraceLeft:
    return com_str_lit_m("tk_BraceLeft");
  case tk_BraceRight:
    return com_str_lit_m("tk_BraceRight");
  case tk_FieldAccess:
    return com_str_lit_m("tk_FieldAccess");
  case tk_Constrain:
    return com_str_lit_m("tk_Constrain");
  case tk_Label:
    return com_str_lit_m("tk_Label");
  case tk_Metadata:
    return com_str_lit_m("tk_Metadata");
  case tk_Bind:
    return com_str_lit_m("tk_Bind");
  case tk_Splat:
    return com_str_lit_m("tk_Splat");
  case tk_Copy:
    return com_str_lit_m("tk_Copy");
  }

  com_assert_unreachable_m("control flow reaches end of token");
}
