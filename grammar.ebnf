# General ideas of the language:
# strings, literals, comments, identifiers, and paths lex first, then macros, then everything else.
# comments must always convey meaningful information, and are linked to an object that they discuss
# AST has 1:1 representation with code

# --- BEGIN BASIC DEFINITIONS ---
spacing = " " | "\t" | "\r";
newline = "\n";
whitespace = spacing | newline;

# shortcut for an arbitrary amount of whitespace
ws = { whitespace };

# digits
binaryDigit = "0" | "1";
octalDigit = binaryDigit | "2" | "3" | "4" | "5" | "6" | "7";
# decimal is special
decimalDigit = octalDigit | "8" | "9";
hexadecimalDigit = digit | "A" | "B" | "C" | "D" | "E" | "F";

digit = decimalDigit;

letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z" ;

symbolExceptBacktick =
         "!" | "\"" | "#" | "$" | "%" | "&" | "'"
       | "(" | ")" | "*" | "+" | "," | "-" | "."
       | "/" | ":" | ";" | "<" | "=" | ">" | "?"
       | "@" | "[" | "\\" | "]" | "^" | "_" | "`"
       | "{" | "|" | "}" | "~" ;

symbol = "`" | symbolExceptBacktick;
# --- END BASIC DEFINITIONS ---

# --- BEGIN COMMENTS ---

# comment scopes define which program should read them
commentScopeElement = letter | digit, { letter | digit };
commentScope = commentScopeElement, { "/", commentScopeElement };

# for both of these, the comment scope is prepended by an @ and appears at the beginning of the comment
# whitespace is mandatory after the scope for single line comments.
lineComment = "#" [ '@', commentScope ], whitespace, { letter | digit | symbol | spacing }, newline;

multilineComment = "#", [ '@', commentScope ], "{", { letter | digit | symbol | whitespace }, "}#";

comment = lineComment | multilineComment;

# zero or more comments interspersed by whitespace
comment_ws = { ws, comment }, ws;

# --- END COMMENTS ---

# --- BEGIN IDENTIFIERS, MACROS & DIGITS ---
# whitespace

underscore = "_";

controlCode = "\\t" | "\\n" | "\\\\" | "\\\"" | "\\'";

# underscore followed by one or more digits or letters
reserved_identifier = underscore, (letter | digit | underscore ), { digit | letter | underscore }
# always starts with a letter
legal_identifier = letter, { digit | letter | underscore };
# an identifer can be either
identifier = identifier | reserved_identifier;

# same deal with macros
reserved_macro_identifier = reserved_identifier, "`";
legal_macro_identifier = identifier, "`";
macro_identifier = reserved_macro_identifier | legal_macro_identifier;

# we can next macros inside of each other
# Macros are invoked lazily, meaning that a macro can yield a macro that will then be evaluated
# A macro invocation ends when it encounters a non nested semicolon.
macroInvocation = macro_identifier, { letter | digit | symbolExceptBacktick | whitespace | macroInvocation }, '`';

# --- END IDENTIFIERS, MACROS & DIGITS ---

# --- BEGIN LITERALS ---

# nil literal
nilLiteral = "nil"

# boolean literal
true = "true";
false = "false";
boolLiteral = true, false;

# int variants
binaryIntLiteral = "0b", binaryDigit, { binaryDigit | underscore };
octalIntLiteral = "0o", octalDigit, { octalDigit | underscore};
decimalIntLiteral = [ "0d" ], decimalDigit, { decimalDigit | underscore}
hexadecimalIntLiteral = "0x", hexadecimalDigit, { hexadecimalDigit | underscore};

# general form
intLiteral = binaryIntLiteral | octalIntLiteral | decimalIntLiteral | hexadecimalIntLiteral;

# float variants
binaryFloatLiteral = binaryIntLiteral ".", binaryDigit | underscore, { binaryDigit | underscore };
octalFloatLiteral = octalIntLiteral, ".", octalDigit | underscore, { octalDigit | underscore };
decimalFloatLiteral = decimalIntLiteral, ".", decimalDigit | underscore, { decimalDigit | underscore };
hexadecimalFloatLiteral = hexadecimalIntLiteral, ".", hexadecimalDigit | underscore, { hexadecimalDigit | underscore };

# float literal
floatLiteral = binaryIntLiteral | octalFloatLiteral | decimalFloatLiteral | hexadecimalFloatLiteral;

# char literal
charLiteral = "'", (letter | digit | symbol | controlCode | whitespace), "'";

# string literal
stringLiteral = "\"", { letter | digit | symbol | controlCode | whitespace }, "\"";

# --- END LITERALS ---

# --- BEGIN LABELS & PATHS ---

# label
label = ws, "'", identifer;
labelReference = label;
labelBinding = label;

path = { ws, namespaceReference, ws, '::' }, identifier;

# namespace bindings
namespaceBinding = ws, identifier;
namespaceReference = ws, identifier;

reference = { ws, namespaceReference, ws, '::' }, identifer;
binding = ws, identifier;

# --- END LABELS & PATHS ---

# --- BEGIN ValExpr ---

# fn values
fnParamDecl = "(", { patExpr }, ws ")";
fnValExpr = fn, ws, fnParamDecl, ws, [ ":", typeExpr ], ws, "=>", valExpr;

# block values
blockValExpr = "{", [ label ], { Stmnt }, ws, "}";

# return values
returnValExpr = "ret", label, valExpr;

# loop val expr
loopValExpr = "loop", [ label ], valExpr;

# reference value exprs
refValExpr = reference;

# can comment before any L1 Value expr
valExprL1 = comment_ws, fnValExpr | blockValExpr | returnValExpr | loopValExpr  | matchValExpr | refValExpr | structLiteralValExpr | macroInvocation;

# l2 val expr
fieldAccessValExpr = ".", ws, identifier;
fnCallValExpr = "(", { valExpr }, ws, ")";
asValExpr = "as", ws, typeExpr;

# You can comment before each case
matchCase = comment_ws, "pat", patExpr, ws, "=>" valExpr;
# match val expr
matchValExpr = "match", ws, "{", { matchCase }, ws, "}";

# can make a comment before the operator
valExprL2 = valExprL1 | (valExprL2, comment_ws, ("&" | "@" | fieldAccessValExpr | fnCallValExpr | asValExpr | matchValExpr ));
valExprL3 = valExprL2 | (comment_ws, ( "++" | "--" | "!" ), valExprL3);
valExprL4 = valExprL3 | (valExprL3, comment_ws, "->", valExprL4);
valExprL5 = valExprL4 | (valExprL4, comment_ws, ( "*" | "/" | "%" ), valExprL5);
valExprL6 = valExprL5 | (valExprL5, comment_ws, ( "-" | "+" ), valExprL6);
valExprL7 = valExprL6 | (valExprL6, comment_ws, ( "<" | ">" | "<=" | ">=" | "==" | "!=" ), valExprL7);
valExprL8 = valExprL7 | (valExprL7, comment_ws, "&&", valExprL8);
valExprL9 = valExprL8 | (valExprL8, comment_ws, "||", valExprL9);
valExprL10 = valExprL9 | (valExprL9, comment_ws, ",", valExprL10);
valExprL11 = valExprL10 | (valExprL10, comment_ws, ( "=" | "+=" | "-=" | "*=" | "/=" | "%=" ), valExprL11);

valExpr = valExprL11;

# --- END ValExpr ---

# --- BEGIN TypeExpr ---

# Group Type Expr (used for ordering unions and tuple precedence)
groupTypeExpr = "{", typeExpr, ws, "}";

# reference type expr
refTypeExpr = reference;

nilTypeExpr = nil;
neverTypeExpr = "never";

# function type expr
fnTypeExpr = "fn", ws, "(", { patExpr }, ws, ")", [ ws, ":", typeExpr ];

# you can comment before each L1 type
typeExprL1 = comment_ws, groupTypeExpr | structTypeExpr | refTypeExpr | fnTypeExpr | nilTypeExpr | neverTypeExpr | macroInvocation;

fieldAccessTypeExpr = ".", ws, identifier;

# comments go before the operator
typeExprL2 = typeExprL1 | (typeExprL2, comment_ws, ( fieldAccessTypeEx | "&" | "@" ));
typeExprL3 = typeExprL2 | (typeExprL2, comment_ws, ",", typeExprL3);
typeExprL4 = typeExprL3 | (typeExprL3, comment_ws, "|", typeExprL4);

typeExpr = typeExprL4;

# --- END TypeExpr ---

# --- BEGIN PatExpr ---

# restricts the value to a pattern, no binding though
valRestrictionPatExpr = ( "==" | "!=" | ">=" | ">" | "<" | "<=" ), valExpr;

# used to discrimate enums
# if omitting identifier, must have a type (binds to the identifier)
typeRestrictionPatExpr = ( ":", typeExpr ) | ( identifier, [ ws, ":", typeExpr ] );

# struct decomposition
# Can comment before each :=
patStructMemberExpr = comment_ws, "pat", patExpr, ":=", ws, ( ".." | identifier );
structPatExpr = "struct", ws, "{", {patStructMemberExpr}, ws, "}";

groupPatExpr = "{", patExpr, ws, "}";

# can comment before
patExprL1 = comment_ws, groupPatExpr | valRestrictionPatExpr | typeRestrictionPatExpr | structPatExpr | macroInvocation;
# comment comes before operator
patExprL2 = patExprL1 | comment_ws, "!", patExprL2
patExprL3 = patExprL2 | (patExprL2, comment_ws, ",", patExprL3);
patExprL4 = patExprL3 | (patExprL3, comment_ws, "|", patExprL4);
patExprL5 = patExprL4 | (patExprL4, comment_ws, "&&", patExprL5);
patExprL6 = patExprL5 | (patExprL5, comment_ws, "||", patExprL6);

patExpr = patExprL6;

# --- END PatExpr ---

# --- BEGIN Stmnt ---

useStmnt = "use", reference, ws, "as", binding;
namespaceStmnt = "namespace", ws, namespaceBinding, ws, "{", {Stmnt}, ws, "}";
valDeclStmnt = "val", patExpr, ws, ":=", valExpr;
typeDeclStmnt = "type", ws, identifier, ws, ":=", typeExpr;

valStmnt = valExpr;

# comments come before each stmnt
Stmnt = comment_ws, useStmnt | namespaceStmnt | valDeclStmnt | typeDeclStmnt | valStmnt | macroInvocation;

# --- BEGIN PROGRAM ---

Program = { Stmnt };

# --- END PROGRAM ---
