use super::ast;
use super::dlogger::DiagnosticLogger;
use super::hir;
use super::hireval::EvalError;
use super::hireval::Val;
use super::thir;
use super::utils::clone_in;
use bumpalo::Bump;
use std::alloc::Allocator;

// this function will attempt to bestow types on all of the components recursing from bottom up
fn tr_synth_expr<'thir, 'hir, 'ast, HA: Allocator + Clone>(
  allocator: &'thir Bump,
  mut dlogger: &mut DiagnosticLogger,
  source: &'hir hir::Expr<'hir, 'ast, HA>,
  label_env: &mut Vec<Option<Val<'hir, 'ast, HA>>>,
  var_env: &mut Vec<Val<'hir, 'ast, HA>>,
) -> thir::Expr<'thir, 'hir, 'ast, &'thir Bump, HA> {
  match source.kind {
    hir::ExprKind::Error => thir::Expr {
      source: source.source,
      kind: thir::ExprKind::Error,
      ty: allocator.alloc(Val::Error(EvalError::InvalidSyntax)),
    },
    hir::ExprKind::Loop(body) => {
      let ty = Val::Nil;

      let body = tr_check_expr(allocator, dlogger, body, label_env, var_env, &ty);

      thir::Expr {
        source: source.source,
        kind: thir::ExprKind::Loop(allocator.alloc(body)),
        ty: allocator.alloc(ty),
      }
    }
    hir::ExprKind::Apply { fun, arg } => {
      // bottom up synthesize the function
      let fun_tr = tr_synth_expr(allocator, dlogger, fun, label_env, var_env);

      if let Val::FunTy { in_ty, out_ty } = fun_tr.ty {
        // typecheck the argument
        let arg_tr = tr_check_expr(allocator, dlogger, arg, label_env, var_env, in_ty);

        // now return the applied function
        thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Apply {
            fun: &fun_tr,
            arg: &arg_tr,
          },
          ty: out_ty,
        }
      } else {
        // log an error that this value isn't callable
        dlogger.log_not_callable(fun_tr.source.range, fun_tr.ty);

        // we will perform a basic synthesis typecheck here to maybe discover any errors
        // however, results won't be used, they're just to inform the user
        let _ = tr_synth_expr(allocator, dlogger, arg, label_env, var_env);

        thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Error,
          ty: allocator.alloc(Val::Error),
        }
      }
    }
    hir::ExprKind::Label { label, body } => {
      // introduce label into the label environment
      label_env.push((
        &label,
        LabelScope {
          declaration: Some(source.source),
          defers: vec![],
          return_ty: None,
        },
      ));

      // now translate the body
      // the body must evaluate to nil
      let body_tr = tr_check_expr(allocator, dlogger, body, label_env, var_env, &Val::Nil);

      // pop label
      let (_, LabelScope { return_ty, .. }) = label_env.pop().unwrap();

      // ensure that there is at least one ret from label, otherwise throw error that label is unused.
      if let Some(return_ty) = return_ty {
        thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Label(allocator.alloc(body_tr)),
          ty: allocator.alloc(return_ty),
        }
      } else {
        dlogger.log_unused_label(source.source.range);

        thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Error,
          ty: allocator.alloc(Val::Error),
        }
      }
    }
    hir::ExprKind::Ret { label, body } => {
      // check that the label exists
      if !lookup_exists(label_env, &label) {
        // return error that we can't find label
        dlogger.log_cannot_find_label_in_scope(source.source.range, &label);

        // for user convenience attempt typecheck and catch errors
        tr_synth_expr(allocator, dlogger, body, label_env, var_env);

        // end up returning error
        return thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Error,
          ty: allocator.alloc(Val::Error),
        };
      }

      // if we have a concrete return type, then we can check type
      let body_tr = match lookup(label_env, &label) {
        LabelScope {
          return_ty: Some(ty),
          ..
        } => tr_check_expr(allocator, dlogger, body, label_env, var_env, ty),
        LabelScope {
          return_ty: None, ..
        } => {
          let tr = tr_synth_expr(allocator, dlogger, body, label_env, var_env);
          update(label_env, &label, |scope| scope.return_ty = Some(&tr.ty));
          tr
        }
      };

      thir::Expr {}
    }
    hir::ExprKind::StructLiteral(fields) => {
      let fields_tr = Vec::new_in(allocator);

      for (key, value) in fields.iter() {
        fields_tr.push((
          &clone_in(allocator, key),
          tr_synth_expr(allocator, dlogger, value, label_env, var_env),
        ));
      }

      let type_tr = Vec::new_in(allocator);

      for (&key, value) in fields_tr.iter() {
        type_tr.push((&key, value.ty));
      }

      thir::Expr {
        source: source.source,
        kind: thir::ExprKind::StructLiteral(fields_tr),
        ty: allocator.alloc(Val::StructTy(type_tr)),
      }
    }
    hir::ExprKind::StructAccess { root, field } => {
      // translate root
      let root_tr = tr_synth_expr(allocator, dlogger, root, label_env, var_env);
      let field_tr = clone_in(allocator, &field);

      if let Val::Struct(fields) = root_tr.ty {
        // if compatible, attempt to look up ty
        if let Some((field_ty, _)) = lookup_maybe(fields, &field_tr) {
          return thir::Expr {
            source: source.source,
            kind: thir::ExprKind::StructAccess {
              root: allocator.alloc(root_tr),
              field: field_tr,
            },
            ty: field_ty,
          };
        } else {
          // if field doesn't exist. return error
          dlogger.log_nonexistent_field(source.source.range, &field);
        }
      } else {
        // if ty is not a struct, return error
        dlogger.log_not_struct(source.source.range);
      }

      // if we had an error, return error
      thir::Expr {
        source: source.source,
        kind: thir::ExprKind::Error,
        ty: allocator.alloc(Val::Error),
      }
    }
    hir::ExprKind::Reference(identifier) => {
      let lkup_val = lookup_maybe(var_env, &identifier);

      if let Some((varscope, debruijin_index)) = lkup_val {
        thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Reference(debruijin_index),
          ty: varscope.ty,
        }
      } else {
        dlogger.log_variable_not_found(source.source.range, &identifier);
        // return error if not exist
        thir::Expr {
          source: source.source,
          kind: thir::ExprKind::Error,
          ty: allocator.alloc(Val::Error),
        }
      }
    }
    hir::ExprKind::Annotate { expr, ty } => thir::Expr {
      source: source.source,
      kind: thir::ExprKind::Error,
      ty: allocator.alloc(Val::Error),
    },
  }
}

// this function will attempt to check types on all the components recursing top down.
// the
fn tr_check_expr<'thir, 'hir, 'ast, HA: Allocator + Clone>(
  allocator: &'thir Bump,
  mut dlogger: &mut DiagnosticLogger,
  source: &'hir hir::Expr<'hir, 'ast, HA>,
  label_env: &mut Vec<(
    &'hir Vec<u8, HA>,
    LabelScope<'thir, 'hir, 'ast, &'thir Bump, HA>,
  )>,
  var_env: &mut Vec<(
    &'hir Vec<u8, HA>,
    VarTyScope<'thir, 'hir, 'ast, &'thir Bump>,
  )>,
  ty: &Val<'hir, 'ast, HA>,
) -> thir::Expr<'thir, 'hir, 'ast, &'thir Bump, HA> {
  match source.kind {
    hir::ExprKind::Error => thir::Expr {
      source: source.source,
      kind: thir::ExprKind::Error,
      ty: allocator.alloc(Val::Error),
    },
    hir::ExprKind::Loop(body) => {
      // Loop has type nil.
      let body = tr_check_expr(allocator, dlogger, body, label_env, var_env, &Val::Nil);

      thir::Expr {
        source: source.source,
        kind: thir::ExprKind::Nil,
        ty: allocator.alloc(Val::Error),
      }
    }
  }
}

pub fn construct_thir<'thir, 'hir, 'ast, HA: Allocator + Clone>(
  hir: &'hir hir::Expr<'hir, 'ast, HA>,
  allocator: &'thir Bump,
  mut dlogger: DiagnosticLogger,
) -> thir::Expr<'thir, 'hir, 'ast, &'thir Bump, HA> {
  tr_synth_expr(allocator, &mut dlogger, hir, &mut vec![], &mut vec![])
}
